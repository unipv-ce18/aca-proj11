<div id="opt" class="step" data-x="4400" data-z="-5000" data-scale="4" data-rotate-z="180">
    <h1>Profiling and optimization</h1>
    <p>Intel VTune has been used to search for eventual bottlenecks and maximize effective core utilization by our
        code.</p>
    <p>We preferred to profile a single large execution of the algorithm over multiple smaller runs to spend as much
        time as possible in the parallel region.</p>
    <p>Here are the optimizations we made thanks to profiling &rightarrow;</p>
</div>

<!-- Beware, optX position is completely CSS defined -->

<div id="opt1" class="step" data-x="800" data-z="-5000" data-scale="4" data-rotate-z="180">
    <h2>Structural element expansion</h2>
    <p>
        We found out that the <code>set1</code> family of intrinsics was taking too much time, so we expanded the
        structural element in memory to the simd width before execution
    </p>
    <div class="opt-bubble opt-bubble-green">
        +10% overall performance boost
    </div>
</div>

<div id="opt3" class="step" data-scale="4" data-rotate-z="180">
    <h2>Improved edge processing</h2>
    <p>
        By using a new kernel type to process top and bottom edges of the image we can skip some border checks and make
        use of SIMD. We replaced the checks with pre calculations of loop ranges too.
    </p>
    <div class="opt-bubble opt-bubble-green">
        + Boost by using specialized kernels
    </div>
    <div class="opt-bubble opt-bubble-red">
        - Min. gain by replacing checks w/ ranges
    </div>
</div>

<div id="opt4" class="step" data-scale="4" data-rotate-z="180">
<h2>Image alignment</h2>
    <p>
        With proper planner parameters and allocation of the images in memory we can ensure alignment of chunks addresses.
    </p>
    <div class="opt-bubble opt-bubble-yellow">
        ~ No performance gain due to the nature of the algorithm
    </div>
</div>

<div id="opt2" class="step" data-scale="4" data-rotate-z="180">
    <h2>Shortcut in skeleton computation</h2>
    <p>
        To implement skeleton we needed new "operators" for union (per-pixel maximum) and subtraction.
    </p>
    <p>
        We created instead a single kernel to perform the required processing in a single sweep, which saved us
        the allocation of an additional temporary imaging memory.
    </p>
</div>

<div id="optresults" class="step semislide" data-x="1000" data-z="-3000" data-scale="4" data-rotate-z="130" data-rotate-x="20"
     data-rotate-y="-30">
    <h1>Optimization results</h1>
    <img src="<%=require(REPORT_IMAGES_DIR + 'bench_opts.svg')%>">
    <img src="<%=require(REPORT_IMAGES_DIR + 'bench_opts_8k.svg')%>">
    <img src="<%=require(REPORT_IMAGES_DIR + 'bench_opts_simd.svg')%>">
    <img src="<%=require(REPORT_IMAGES_DIR + 'bench_opts_8k_simd.svg')%>">
<div class="notes">further speedup of ~1.4 ;
    Similar results with SIMD</div>
</div>
