:nofooter:
:imagesdir: images
:stem: latexmath
:source-highlighter: rouge
:toc: preamble

= Parallelizing Mathematical Morphology
D. Lietavec, L. Zanussi — Advanced Computer Architecture (2018-2019)

__
Our project for the course consisted in the creation and the subsequent parallelization of a set of Mathematical
Morphology operators — the result is a C++ codebase depending on OpenCV for image I/O and OpenMP, which was used
to manage the thread pool and initially plan the parallel execution of the kernel.
We will then discuss about switching to a custom planning algorithm, and observe the results.
__

include::01-morphology.asc[]
include::02-serial.asc[]
include::03-parallel_openmp.asc[]
include::04-custom_planning.asc[]
include::05-kernel_code_design.asc[]
include::06-simd_with_intrinsics.asc[]
include::07-profiling_and_optimization.asc[]
include::08-results.asc[]
include::09-cuda_approach.asc[]

== Conclusion

// Cite morph, morphbench, use of environment variables and arguments, sane defaults

The way forward for algorithms of this kind is to switch to a GPGPU paradigm by the means of OpenCL or CUDA — we must
however consider that the spin-up time of CUDA might be excessive and would negatively impact the performance when
working over single HD sized images and its use may be more appropriate when working over batches of images (or less,
very large pictures).

Another possible addition is a porting to ARM and measuring the speedup obtained by parallelization on that platform.
NEON (SIMD) instructions could be used and tested as well.
