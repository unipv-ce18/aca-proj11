:imagesdir: images
:nofooter:
:stem: latexmath
:source-highlighter: rouge
:toc: preamble

= Parallelizing Mathematical Morphology
D. Lietavec, L. Zanussi — Advanced Computer Architecture (2018-2019)

__
Our project for the course consisted in the creation and the subsequent parallelization of a set of Mathematical
Morphology operators — the result is a C++ codebase depending on OpenCV for image I/O and OpenMP, which was used
to manage the thread pool and initially plan the parallel execution of the kernel.
We will then discuss about switching to a custom planning algorithm, and observe the results.
__

== Morphological operators

Mathematical Morphology is a branch of Computer Vision act to the analysis and processing of geometrical structures.
The first thing we did was to perform some research on the topic, we then picked the operators we wanted to implement
and write a first concept implementation in MATLAB.

=== Dilation and erosion

...

=== Skeleton

...

== Serial implementation

...

== Parallelization with OpenMP

Where needed, parallelization of these algorithms combined with the use of the right CPU features allows to achieve
real-time HD video processing in less than 25ms.

...

include::06-custom_planning.asc[]
include::07-kernel_code_design.asc[]
include::08-simd_with_intrinsics.asc[]
include::09-profiling_and_optimization.asc[]

== Experimental results

...

=== Comparing compilers

Another experiment is to measure the performance of the binary produced by different toolchains. GCC and LLVM Clang
are free and open source compilers available for all major platforms, while Microsoft's optimizing compiler `cl` is
part of the Visual Studio toolchain.

All binaries were compiled in release mode optimized for maximum speed (`-O3` in GCC and Clang, `/O2` for cl).
All the tools were at their latest version at the time of this writing.


vegalite::vega/bench_compilers.json[]
vegalite::vega/bench_compilers_simd.json[]

It is interesting to note that Clang performs slightly better than GCC with no use of SIMD instructions, while GCC
outperforms it when SIMD is on. The trend remains with smaller images, where Clang's speedup in non-SIMD kernels
becomes more noticeable.

Even after additional research we weren't able to get faster builds from MSVC.

NOTE: MSVC's ABI is not compatible with GCC and Clang, dependencies like OpenCV need to be re-compiled for each ABI.

== Conclusion

// Cite morph, morphbench, use of environment variables and arguments, sane defaults

// Further improvements, using OpenCL/CUDA or porting to ARM, using NEON
